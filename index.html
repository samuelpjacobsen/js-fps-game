<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Game Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        #gameContainer {
            width: 100%;
            height: 100%;
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(#001f3f, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #title {
            font-size: 3em;
            margin-bottom: 40px;
            color: #ff6700;
        }
        .menuItem {
            margin: 10px;
            padding: 15px 30px;
            font-size: 1.2em;
            border: none;
            border-radius: 5px;
            background-color: #ff6700;
            color: white;
            cursor: pointer;
        }
        .menuItem:hover {
            background-color: #ff8533;
        }
        #joinForm {
            display: none;
            margin-top: 20px;
        }
        #gameId {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
        }
        #nameInput {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            margin-bottom: 20px;
        }
        #gameUI {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2em;
        }
        #health {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #ammo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #playersList {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            max-width: 200px;
        }
        #gameCode {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #killFeed {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            width: 300px;
            text-align: center;
        }
        .killMessage {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 5px;
            animation: fadeOut 3s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="menu">
            <h1 id="title">FPS Game Online</h1>
            <input type="text" id="nameInput" placeholder="Seu nome" maxlength="16">
            <button id="createBtn" class="menuItem">Criar Jogo</button>
            <button id="joinBtn" class="menuItem">Entrar em Jogo</button>
            <div id="joinForm">
                <input type="text" id="gameId" placeholder="Código do jogo">
                <button id="connectBtn" class="menuItem">Conectar</button>
            </div>
            <div style="margin-top: 40px; text-align: center;">
                <h3>Controles:</h3>
                <p>WASD - Movimento</p>
                <p>Mouse - Olhar</p>
                <p>Clique - Atirar</p>
                <p>R - Recarregar</p>
                <p>F - Mudar Arma</p>
                <p>Espaço - Pular</p>
                <p>Esc - Menu</p>
            </div>
        </div>
        <div id="gameUI">
            <div id="crosshair">+</div>
            <div id="health">Vida: 100</div>
            <div id="ammo">Munição: 30/90</div>
            <div id="playersList"></div>
            <div id="gameCode"></div>
            <div id="killFeed"></div>
        </div>
    </div>

    <!-- Carregando as bibliotecas com vários CDNs de backup -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script>
    
    <script>
        // Esperar o DOM carregar
        document.addEventListener('DOMContentLoaded', function() {
            // Verificar se THREE foi carregado corretamente
            if (typeof THREE === 'undefined') {
                alert('Erro ao carregar Three.js. Tente recarregar a página ou use outro navegador.');
                return;
            }

            // Verificar se Peer foi carregado corretamente
            if (typeof Peer === 'undefined') {
                alert('Erro ao carregar PeerJS. Tente recarregar a página ou use outro navegador.');
                return;
            }

            // Constantes
            const PLAYER_HEIGHT = 1.8;
            const PLAYER_RADIUS = 0.5;
            const MOVE_SPEED = 0.15;
            const JUMP_FORCE = 0.3;
            const MAP_SIZE = 40;
            const GRAVITY = 0.01;
            
            // Elementos da UI
            const menu = document.getElementById('menu');
            const gameUI = document.getElementById('gameUI');
            const createBtn = document.getElementById('createBtn');
            const joinBtn = document.getElementById('joinBtn');
            const connectBtn = document.getElementById('connectBtn');
            const joinForm = document.getElementById('joinForm');
            const nameInput = document.getElementById('nameInput');
            const gameIdInput = document.getElementById('gameId');
            const healthUI = document.getElementById('health');
            const ammoUI = document.getElementById('ammo');
            const playersListUI = document.getElementById('playersList');
            const gameCodeUI = document.getElementById('gameCode');
            const killFeedUI = document.getElementById('killFeed');
            const gameContainer = document.getElementById('gameContainer');
            
            // Estado do jogo
            let scene, camera, renderer;
            let playerObject, playerBox;
            let players = {};
            let peer, connections = {};
            let gameId = null;
            let isHost = false;
            let isPlaying = false;
            let movement = { forward: false, backward: false, left: false, right: false };
            let mouseControls = { x: 0, y: 0 };
            let isPointerLocked = false;
            let velocity = { x: 0, y: 0, z: 0 };
            let onGround = true;
            let health = 100;
            let ammo = { current: 30, total: 90 };
            let isDead = false;
            let kills = 0;
            let deaths = 0;
            let weaponType = 'rifle';
            let isReloading = false;
            let bulletLines = [];

            // Criar efeitos sonoros
            const createShotSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Criar oscilador para som de tiro
                const createShot = () => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    // Configurar som de tiro (tipo "laser" rápido)
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(220, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    
                    gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    osc.start();
                    osc.stop(audioContext.currentTime + 0.2);
                };
                
                return createShot;
            };
            
            let playShotSound;
            
            // Inicialização do Three.js
            function initGame() {
                // Criar cena
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Céu azul
                
                // Criar câmera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.y = PLAYER_HEIGHT;
                
                // Criar renderizador
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                gameContainer.appendChild(renderer.domElement);
                
                // Inicializar som de tiro
                try {
                    playShotSound = createShotSound();
                } catch (e) {
                    console.warn('Áudio não suportado:', e);
                    playShotSound = () => {}; // Função vazia caso áudio não seja suportado
                }
                
                // Criar mapa
                createMap();
                
                // Criar jogador
                createPlayer();
                
                // Adicionar luzes
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Adicionar eventos
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('pointerlockchange', onPointerLockChange);
                
                // Iniciar animação
                animate();
            }
            
            // Criar mapa básico
            function createMap() {
                // Chão
                const floorGeometry = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE);
                const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                scene.add(floor);
                
                // Paredes externas
                const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
                
                // Norte
                const wallN = new THREE.Mesh(
                    new THREE.BoxGeometry(MAP_SIZE, 5, 1),
                    wallMaterial
                );
                wallN.position.set(0, 2.5, -MAP_SIZE/2);
                scene.add(wallN);
                
                // Sul
                const wallS = new THREE.Mesh(
                    new THREE.BoxGeometry(MAP_SIZE, 5, 1),
                    wallMaterial
                );
                wallS.position.set(0, 2.5, MAP_SIZE/2);
                scene.add(wallS);
                
                // Leste
                const wallE = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 5, MAP_SIZE),
                    wallMaterial
                );
                wallE.position.set(MAP_SIZE/2, 2.5, 0);
                scene.add(wallE);
                
                // Oeste
                const wallW = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 5, MAP_SIZE),
                    wallMaterial
                );
                wallW.position.set(-MAP_SIZE/2, 2.5, 0);
                scene.add(wallW);
                
                // Obstáculos
                for (let i = 0; i < 10; i++) {
                    const size = 1 + Math.random() * 3;
                    const x = (Math.random() - 0.5) * (MAP_SIZE - size);
                    const z = (Math.random() - 0.5) * (MAP_SIZE - size);
                    
                    const box = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    box.position.set(x, size/2, z);
                    scene.add(box);
                }
            }
            
            // Criar jogador
            function createPlayer() {
                // Grupo para o jogador
                playerObject = new THREE.Group();
                
                // Corpo do jogador
                const geometry = new THREE.BoxGeometry(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2);
                const material = new THREE.MeshStandardMaterial({ color: 0x0000FF });
                playerBox = new THREE.Mesh(geometry, material);
                playerBox.position.y = PLAYER_HEIGHT / 2;
                playerObject.add(playerBox);
                
                // Adicionar à cena
                scene.add(playerObject);
                
                // Posicionar câmera
                camera.position.set(0, PLAYER_HEIGHT, 0);
                
                // Armazenar jogador local na lista
                const myId = peer ? peer.id : 'local';
                players[myId] = {
                    id: myId,
                    name: nameInput.value || 'Player',
                    object: playerObject,
                    health: 100,
                    ammo: { current: 30, total: 90 },
                    weaponType: 'rifle',
                    isDead: false,
                    kills: 0,
                    deaths: 0,
                    isReloading: false
                };
            }
            
            // Criar jogador remoto
            function createRemotePlayer(id, name, position) {
                // Se já existe, atualizar posição
                if (players[id]) {
                    players[id].object.position.copy(position);
                    return;
                }
                
                // Grupo para o jogador
                const playerObj = new THREE.Group();
                
                // Corpo do jogador
                const geometry = new THREE.BoxGeometry(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2);
                const material = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
                const box = new THREE.Mesh(geometry, material);
                box.position.y = PLAYER_HEIGHT / 2;
                playerObj.add(box);
                
                // Posicionar
                playerObj.position.copy(position);
                
                // Adicionar à cena
                scene.add(playerObj);
                
                // Armazenar na lista
                players[id] = {
                    id: id,
                    name: name,
                    object: playerObj,
                    health: 100,
                    ammo: { current: 30, total: 90 },
                    weaponType: 'rifle',
                    isDead: false,
                    kills: 0,
                    deaths: 0,
                    isReloading: false
                };
                
                // Atualizar lista de jogadores
                updatePlayersList();
            }
            
            // Redimensionar janela
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Controle de teclado
            function onKeyDown(event) {
                if (!isPlaying) return;
                
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        movement.forward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        movement.backward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        movement.left = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        movement.right = true;
                        break;
                    case 'Space':
                        if (onGround) {
                            velocity.y = JUMP_FORCE;
                            onGround = false;
                        }
                        break;
                    case 'KeyR':
                        reload();
                        break;
                    case 'KeyF':
                        switchWeapon();
                        break;
                    case 'Escape':
                        if (isPointerLocked) {
                            document.exitPointerLock();
                        }
                        break;
                }
            }
            
            function onKeyUp(event) {
                if (!isPlaying) return;
                
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        movement.forward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        movement.backward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        movement.left = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        movement.right = false;
                        break;
                }
            }
            
            // Controle de mouse
            function onMouseDown(event) {
                if (!isPlaying || !isPointerLocked) return;
                
                if (event.button === 0) { // botão esquerdo
                    shoot();
                }
            }
            
            function onMouseMove(event) {
                if (!isPlaying || !isPointerLocked) return;
                
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                // Rotação horizontal
                camera.rotation.y -= movementX * 0.002;
                
                // Rotação vertical (limitada) - CORRIGIDO NOVAMENTE: 
                // Agora o movimentY negativo olha para baixo (direção natural)
                mouseControls.y -= movementY * 0.002;
                mouseControls.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseControls.y));
                camera.rotation.x = mouseControls.y;
            }
            
            // Controle de bloqueio do ponteiro
            function onPointerLockChange() {
                isPointerLocked = document.pointerLockElement === document.body;
            }
            
            // Funções de jogabilidade
            function shoot() {
                if (isDead || isReloading || ammo.current <= 0) return;
                
                // Tocar som de tiro
                playShotSound();
                
                // Diminuir munição
                ammo.current--;
                
                // Atualizar UI
                updateAmmoUI();
                
                // Raycasting para detectar colisões
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                // Ponto inicial - posição da câmera
                const startPoint = camera.position.clone();
                
                // Ponto final padrão (100 unidades na direção da mira)
                let endPoint = startPoint.clone().add(raycaster.ray.direction.clone().multiplyScalar(100));
                
                // Verificar todos os jogadores exceto o local
                const targets = [];
                for (const id in players) {
                    if (id !== peer.id && !players[id].isDead) {
                        targets.push(players[id].object.children[0]); // playerBox
                    }
                }
                
                // Verificar colisões
                const intersects = raycaster.intersectObjects(targets);
                
                if (intersects.length > 0) {
                    // Atualizar ponto final para o ponto de colisão
                    endPoint = intersects[0].point;
                    
                    // Identificar jogador atingido
                    const hitObject = intersects[0].object;
                    let hitPlayerId = null;
                    
                    for (const id in players) {
                        if (players[id].object.children[0] === hitObject) {
                            hitPlayerId = id;
                            break;
                        }
                    }
                    
                    if (hitPlayerId) {
                        // Calcular dano baseado na arma
                        let damage = 0;
                        switch (weaponType) {
                            case 'pistol': damage = 20; break;
                            case 'rifle': damage = 10; break;
                            case 'shotgun': damage = 30; break;
                        }
                        
                        // Enviar informação de hit
                        sendHitInfo(hitPlayerId, damage);
                        
                        // Mostrar feedback
                        addKillFeedMessage(`Você atingiu ${players[hitPlayerId].name}`);
                    }
                }
                
                // Criar linha de tiro tracejada
                createBulletLine(startPoint, endPoint);
                
                // Verificar recarga
                if (ammo.current === 0 && ammo.total > 0) {
                    reload();
                }
            }
            
            // Criar linha tracejada para o tiro
            function createBulletLine(start, end) {
                // Criar pontos para linha tracejada
                const points = [];
                const segmentLength = 0.5; // Tamanho de cada segmento
                const gap = 0.2; // Tamanho do espaço entre segmentos
                
                // Calcular direção e distância
                const direction = end.clone().sub(start).normalize();
                const distance = start.distanceTo(end);
                
                // Criar pontos para cada segmento
                let currentDist = 0;
                while (currentDist < distance) {
                    // Adicionar início do segmento
                    points.push(start.clone().add(direction.clone().multiplyScalar(currentDist)));
                    
                    // Calcular final do segmento
                    const segmentEnd = Math.min(currentDist + segmentLength, distance);
                    points.push(start.clone().add(direction.clone().multiplyScalar(segmentEnd)));
                    
                    // Avançar para o próximo segmento
                    currentDist += segmentLength + gap;
                }
                
                // Criar material colorido baseado na arma atual
                let bulletColor;
                switch (weaponType) {
                    case 'pistol': bulletColor = 0xffff00; break; // Amarelo
                    case 'rifle': bulletColor = 0x00ffff; break;  // Ciano
                    case 'shotgun': bulletColor = 0xff0000; break; // Vermelho
                    default: bulletColor = 0xffffff; // Branco
                }
                
                // Criar geometria da linha
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: bulletColor,
                    linewidth: 3
                });
                
                // Criar linha e adicionar à cena
                const line = new THREE.LineSegments(geometry, material);
                scene.add(line);
                
                // Adicionar à lista de linhas de tiro
                bulletLines.push({
                    line: line,
                    createdAt: Date.now()
                });
            }
            
            // Atualizar e remover linhas de tiro
            function updateBulletLines() {
                const now = Date.now();
                const linesToRemove = [];
                
                // Verificar cada linha
                for (let i = 0; i < bulletLines.length; i++) {
                    const bullet = bulletLines[i];
                    const age = now - bullet.createdAt;
                    
                    // Duração de 200ms
                    if (age > 200) {
                        // Remover da cena e marcar para remoção da lista
                        scene.remove(bullet.line);
                        bullet.line.geometry.dispose();
                        bullet.line.material.dispose();
                        linesToRemove.push(i);
                    } else {
                        // Atualizar opacidade
                        bullet.line.material.opacity = 1 - (age / 200);
                    }
                }
                
                // Remover da lista (de trás para frente para evitar problemas de índice)
                for (let i = linesToRemove.length - 1; i >= 0; i--) {
                    bulletLines.splice(linesToRemove[i], 1);
                }
            }
            
            function reload() {
                if (isDead || isReloading || ammo.current === 30 || ammo.total === 0) return;
                
                isReloading = true;
                
                // Atualizar UI
                ammoUI.textContent = 'Recarregando...';
                
                // Tempo de recarga
                setTimeout(() => {
                    const needed = 30 - ammo.current;
                    const available = Math.min(needed, ammo.total);
                    
                    ammo.total -= available;
                    ammo.current += available;
                    
                    isReloading = false;
                    
                    // Atualizar UI
                    updateAmmoUI();
                    
                    // Atualizar dados remotos
                    sendPlayerUpdate();
                }, 2000);
            }
            
            function switchWeapon() {
                if (isDead || isReloading) return;
                
                // Ciclar entre as armas
                switch (weaponType) {
                    case 'pistol': weaponType = 'rifle'; break;
                    case 'rifle': weaponType = 'shotgun'; break;
                    case 'shotgun': weaponType = 'pistol'; break;
                }
                
                // Atualizar UI
                updateAmmoUI();
                
                // Atualizar dados remotos
                sendPlayerUpdate();
            }
            
            function takeDamage(amount, attackerId) {
                if (isDead) return false;
                
                health -= amount;
                health = Math.max(0, health);
                
                // Atualizar UI
                updateHealthUI();
                
                // Verificar morte
                if (health <= 0) {
                    die(attackerId);
                    return true;
                }
                
                return false;
            }
            
            function die(killerId) {
                isDead = true;
                deaths++;
                
                // Adicionar kill para o assassino
                if (killerId && players[killerId]) {
                    players[killerId].kills++;
                    
                    // Mensagem no feed
                    addKillFeedMessage(`${players[killerId].name} eliminou você!`);
                } else {
                    addKillFeedMessage('Você morreu!');
                }
                
                // Ocultar jogador
                playerBox.visible = false;
                
                // Atualizar UI
                updatePlayersList();
                
                // Enviar atualização
                sendPlayerUpdate();
                
                // Respawn após um tempo
                setTimeout(respawn, 5000);
            }
            
            function respawn() {
                if (!isDead) return;
                
                // Restaurar estado
                isDead = false;
                health = 100;
                ammo = { current: 30, total: 90 };
                isReloading = false;
                
                // Posição aleatória no mapa
                const x = (Math.random() - 0.5) * (MAP_SIZE - 4);
                const z = (Math.random() - 0.5) * (MAP_SIZE - 4);
                playerObject.position.set(x, 0, z);
                camera.position.set(x, PLAYER_HEIGHT, z);
                
                // Mostrar modelo
                playerBox.visible = true;
                
                // Atualizar UI
                updateHealthUI();
                updateAmmoUI();
                updatePlayersList();
                
                // Mensagem no feed
                addKillFeedMessage('Você renasceu!');
                
                // Enviar atualização
                sendPlayerUpdate();
            }
            
            // Funções de UI
            function updateHealthUI() {
                healthUI.textContent = `Vida: ${health}`;
            }
            
            function updateAmmoUI() {
                ammoUI.textContent = `${weaponType.charAt(0).toUpperCase() + weaponType.slice(1)}: ${ammo.current}/${ammo.total}`;
            }
            
            function updatePlayersList() {
                let html = '<h3>Jogadores</h3>';
                
                for (const id in players) {
                    const player = players[id];
                    html += `<div>${player.name} (${player.kills}/${player.deaths})</div>`;
                }
                
                playersListUI.innerHTML = html;
            }
            
            function addKillFeedMessage(message) {
                const msgElement = document.createElement('div');
                msgElement.className = 'killMessage';
                msgElement.textContent = message;
                
                killFeedUI.appendChild(msgElement);
                
                // Remover após animação
                setTimeout(() => {
                    if (killFeedUI.contains(msgElement)) {
                        killFeedUI.removeChild(msgElement);
                    }
                }, 3000);
            }
            
            // Animação do jogo
            function animate() {
                requestAnimationFrame(animate);
                
                if (isPlaying) {
                    // Gravidade
                    if (!onGround) {
                        velocity.y -= GRAVITY;
                    }
                    
                    // Movimento do jogador
                    const direction = new THREE.Vector3();
                    
                    // Frente/trás
                    if (movement.forward) direction.z -= 1;
                    if (movement.backward) direction.z += 1;
                    
                    // Esquerda/direita
                    if (movement.left) direction.x -= 1;
                    if (movement.right) direction.x += 1;
                    
                    // Normalizar e rotacionar direção
                    if (direction.length() > 0) {
                        direction.normalize();
                        
                        // Rotacionar com base na câmera
                        direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
                        
                        // Aplicar movimento
                        velocity.x = direction.x * MOVE_SPEED;
                        velocity.z = direction.z * MOVE_SPEED;
                    } else {
                        // Desacelerar
                        velocity.x *= 0.9;
                        velocity.z *= 0.9;
                    }
                    
                    // Aplicar velocidade
                    playerObject.position.x += velocity.x;
                    playerObject.position.y += velocity.y;
                    playerObject.position.z += velocity.z;
                    
                    // Verificar colisão com o chão
                    if (playerObject.position.y < 0) {
                        playerObject.position.y = 0;
                        velocity.y = 0;
                        onGround = true;
                    }
                    
                    // Limitar movimento ao mapa
                    const border = MAP_SIZE / 2 - PLAYER_RADIUS;
                    playerObject.position.x = Math.max(-border, Math.min(border, playerObject.position.x));
                    playerObject.position.z = Math.max(-border, Math.min(border, playerObject.position.z));
                    
                    // Sincronizar câmera com jogador
                    camera.position.x = playerObject.position.x;
                    camera.position.z = playerObject.position.z;
                    camera.position.y = playerObject.position.y + PLAYER_HEIGHT;
                    
                    // Atualizar linhas de tiro
                    updateBulletLines();
                    
                    // Enviar atualização de posição
                    const now = Date.now();
                    if (now - lastUpdate > 50) { // Limitar para não sobrecarregar a rede
                        sendPlayerUpdate();
                        lastUpdate = now;
                    }
                }
                
                renderer.render(scene, camera);
            }
            
            // Funções de rede
            function initNetwork() {
                // Gerar ID aleatório
                const peerId = generateId();
                
                // Inicializar PeerJS
                peer = new Peer(peerId);
                
                // Evento de conexão
                peer.on('open', (id) => {
                    console.log('Connected with ID: ' + id);
                });
                
                // Lidar com erros
                peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    alert('Erro de conexão: ' + err.message);
                });
                
                // Receber conexões
                peer.on('connection', (conn) => {
                    handleConnection(conn);
                });
            }
            
            function createHostGame() {
                if (!peer) {
                    alert('Erro ao conectar ao servidor. Tente novamente.');
                    return;
                }
                
                // Gerar código do jogo (usando o peer ID)
                gameId = peer.id;
                isHost = true;
                
                // Exibir código
                gameCodeUI.textContent = `Código: ${gameId}`;
                
                // Iniciar jogo
                startGame();
            }
            
            function joinExistingGame() {
                const hostId = gameIdInput.value.trim();
                
                if (!hostId) {
                    alert('Por favor, insira o código do jogo.');
                    return;
                }
                
                // Conectar ao host
                const conn = peer.connect(hostId);
                
                conn.on('open', () => {
                    console.log('Connected to host!');
                    
                    // Armazenar conexão
                    connections[hostId] = conn;
                    
                    // Armazenar código do jogo
                    gameId = hostId;
                    isHost = false;
                    
                    // Exibir código
                    gameCodeUI.textContent = `Código: ${gameId}`;
                    
                    // Enviar informações do jogador
                    sendPlayerJoin(conn);
                    
                    // Configurar recebimento de dados
                    conn.on('data', (data) => {
                        handleData(data, hostId);
                    });
                    
                    // Lidar com desconexão
                    conn.on('close', () => {
                        alert('Desconectado do host. Voltando ao menu.');
                        endGame();
                    });
                    
                    // Iniciar jogo
                    startGame();
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    alert('Erro ao conectar ao jogo. Verifique o código e tente novamente.');
                });
            }
            
            function handleConnection(conn) {
                console.log('New player connecting:', conn.peer);
                
                conn.on('open', () => {
                    // Armazenar conexão
                    connections[conn.peer] = conn;
                    
                    // Configurar recebimento de dados
                    conn.on('data', (data) => {
                        handleData(data, conn.peer);
                    });
                    
                    // Lidar com desconexão
                    conn.on('close', () => {
                        console.log('Player disconnected:', conn.peer);
                        
                        // Remover conexão
                        delete connections[conn.peer];
                        
                        // Remover jogador
                        if (players[conn.peer]) {
                            scene.remove(players[conn.peer].object);
                            delete players[conn.peer];
                            
                            // Atualizar UI
                            updatePlayersList();
                            
                            // Notificar outros jogadores
                            if (isHost) {
                                broadcast({
                                    type: 'player_leave',
                                    id: conn.peer
                                }, [conn.peer]);
                            }
                        }
                    });
                });
            }
            
            function handleData(data, senderId) {
                switch (data.type) {
                    case 'player_join':
                        // Criar jogador remoto
                        createRemotePlayer(data.id, data.name, data.position);
                        
                        // Se somos o host, informar outros jogadores
                        if (isHost) {
                            // Enviar informações de todos os jogadores ao novo jogador
                            // Incluindo o próprio host
                            for (const id in players) {
                                if (id !== data.id) {
                                    connections[data.id].send({
                                        type: 'player_join',
                                        id: id,
                                        name: players[id].name,
                                        position: {
                                            x: players[id].object.position.x,
                                            y: players[id].object.position.y,
                                            z: players[id].object.position.z
                                        }
                                    });
                                }
                            }
                            
                            // Informar outros jogadores sobre o novo jogador
                            broadcast({
                                type: 'player_join',
                                id: data.id,
                                name: data.name,
                                position: data.position
                            }, [data.id]);
                        }
                        break;
                        
                    case 'player_update':
                        if (players[data.id]) {
                            // Atualizar posição
                            players[data.id].object.position.set(
                                data.position.x,
                                data.position.y,
                                data.position.z
                            );
                            
                            // Atualizar rotação
                            if (data.rotation) {
                                players[data.id].object.rotation.set(
                                    data.rotation.x,
                                    data.rotation.y,
                                    data.rotation.z
                                );
                            }
                            
                            // Atualizar status
                            players[data.id].health = data.health;
                            players[data.id].isDead = data.isDead;
                            players[data.id].weaponType = data.weaponType;
                            players[data.id].isReloading = data.isReloading;
                            players[data.id].kills = data.kills;
                            players[data.id].deaths = data.deaths;
                            
                            // Atualizar visibilidade
                            players[data.id].object.children[0].visible = !data.isDead;
                            
                            // Atualizar UI
                            updatePlayersList();
                        }
                        break;
                        
                    case 'player_leave':
                        if (players[data.id]) {
                            scene.remove(players[data.id].object);
                            delete players[data.id];
                            
                            // Atualizar UI
                            updatePlayersList();
                        }
                        break;
                        
                    case 'hit':
                        if (data.targetId === peer.id) {
                            // Fomos atingidos
                            const killed = takeDamage(data.damage, data.attackerId);
                            
                            // Enviar confirmação
                            sendTo(data.attackerId, {
                                type: 'hit_confirm',
                                targetId: peer.id,
                                killed: killed
                            });
                        }
                        break;
                        
                    case 'hit_confirm':
                        if (data.killed && players[data.targetId]) {
                            // Atualizar kill count
                            kills++;
                            
                            // Atualizar UI
                            updatePlayersList();
                            
                            // Mensagem no feed
                            addKillFeedMessage(`Você eliminou ${players[data.targetId].name}!`);
                        }
                        break;
                }
            }
            
            function sendPlayerJoin(connection) {
                connection.send({
                    type: 'player_join',
                    id: peer.id,
                    name: nameInput.value || 'Player',
                    position: {
                        x: playerObject.position.x,
                        y: playerObject.position.y,
                        z: playerObject.position.z
                    }
                });
            }
            
            let lastUpdate = 0;
            
            function sendPlayerUpdate() {
                // Preparar dados
                const data = {
                    type: 'player_update',
                    id: peer.id,
                    position: {
                        x: playerObject.position.x,
                        y: playerObject.position.y,
                        z: playerObject.position.z
                    },
                    rotation: {
                        x: camera.rotation.x,
                        y: camera.rotation.y,
                        z: camera.rotation.z
                    },
                    health: health,
                    isDead: isDead,
                    weaponType: weaponType,
                    isReloading: isReloading,
                    kills: kills,
                    deaths: deaths
                };
                
                // Enviar para todos
                broadcast(data);
            }
            
            function sendHitInfo(targetId, damage) {
                // Enviar informação de hit
                sendTo(targetId, {
                    type: 'hit',
                    targetId: targetId,
                    damage: damage,
                    attackerId: peer.id
                });
            }
            
            function sendTo(peerId, data) {
                if (connections[peerId]) {
                    try {
                        connections[peerId].send(data);
                    } catch (error) {
                        console.error('Error sending data:', error);
                    }
                }
            }
            
            function broadcast(data, exclude = []) {
                for (const peerId in connections) {
                    if (!exclude.includes(peerId)) {
                        sendTo(peerId, data);
                    }
                }
            }
            
            // Funções auxiliares
            function generateId() {
                return Math.random().toString(36).substring(2, 9);
            }
            
            // Funções de menu
            function startGame() {
                // Esconder menu
                menu.style.display = 'none';
                gameUI.style.display = 'block';
                
                // Iniciar captura do mouse
                document.body.requestPointerLock();
                
                // Iniciar jogo
                isPlaying = true;
            }
            
            function endGame() {
                // Mostrar menu
                isPlaying = false;
                menu.style.display = 'flex';
                gameUI.style.display = 'none';
                
                // Limpar jogadores
                for (const id in players) {
                    if (id !== peer.id) {
                        scene.remove(players[id].object);
                    }
                }
                
                // Limpar linhas de tiro
                bulletLines.forEach(bullet => {
                    scene.remove(bullet.line);
                    bullet.line.geometry.dispose();
                    bullet.line.material.dispose();
                });
                bulletLines = [];
                
                // Resetar conexões
                for (const id in connections) {
                    connections[id].close();
                }
                
                connections = {};
                
                // Manter apenas jogador local
                const myId = peer.id;
                const localPlayer = players[myId];
                players = {};
                
                if (localPlayer) {
                    players[myId] = localPlayer;
                }
                
                // Resetar status
                health = 100;
                ammo = { current: 30, total: 90 };
                isDead = false;
                kills = 0;
                deaths = 0;
                weaponType = 'rifle';
                isReloading = false;
                
                // Resetar posição
                playerObject.position.set(0, 0, 0);
                playerBox.visible = true;
                
                // Libertar mouse
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Limpar UI
                killFeedUI.innerHTML = '';
                playersListUI.innerHTML = '';
            }
            
            // Configurar botões do menu
            createBtn.addEventListener('click', () => {
                if (!nameInput.value.trim()) {
                    alert('Por favor, insira seu nome.');
                    return;
                }
                
                createHostGame();
            });
            
            joinBtn.addEventListener('click', () => {
                joinForm.style.display = joinForm.style.display === 'none' ? 'block' : 'none';
            });
            
            connectBtn.addEventListener('click', () => {
                if (!nameInput.value.trim()) {
                    alert('Por favor, insira seu nome.');
                    return;
                }
                
                joinExistingGame();
            });
            
            // Inicializar jogo e rede
            initNetwork();
            initGame();
        });
    </script>
</body>
</html>
